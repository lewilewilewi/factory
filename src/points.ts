import { Connection, PublicKey } from '@solana/web3.js';
import { Program, Provider, web3, BN } from '@project-serum/anchor';
// import { TOKEN_PROGRAM_ID } from '@solana/spl-token';
import { IDL } from './types/points_program';
import {
  DomainAccount,
  PointsModifier,
  PointCategoryAccount,
  UserPointsAccount,
  UserPointsAccountItem,
  PointsModifierItem,
} from './types/points_accounts';
import type { Points } from './types/points_program';

/** Export account types */
export * from './types/points_accounts';
export * from './types/points_program';

const DOMAIN_ACCOUNT_SEED = Buffer.from('"PointsDomain"');
const POINT_CATEGORY_ACCOUNT_SEED = Buffer.from('"PointCategoryAccount"');
const POINT_MODIFIER_SEED = Buffer.from('"PointModifier"');
const USER_POINTS_ACCOUNT_SEED = Buffer.from('"UserPointsAccount"');

/**
 * Returns the public key and bump seed for the Domain Account
 *
 * @param programId - deployed program ID for Points program
 * @returns [Domain account public key, bump seed]
 */
export async function findDomainAccount(
  programId: PublicKey
): Promise<[PublicKey, number]> {
  return await PublicKey.findProgramAddress([DOMAIN_ACCOUNT_SEED], programId);
}

/**
 * Returns the public key and bump seed for the Point Category Account
 *
 * @param label - Point Category Account label
 * @param programId - deployed program ID for Points program
 * @returns [Point Category Account public key, bump seed]
 */
export const findPointCategoryAccount = async (
  label: string,
  programId: PublicKey
): Promise<[PublicKey, number]> => {
  return await PublicKey.findProgramAddress(
    [POINT_CATEGORY_ACCOUNT_SEED, Buffer.from(label)],
    programId
  );
};

/**
 * Returns the public key and bump seed for the User Points Account
 *
 * @param pointsCategoryAccountKey - Points Category Account public key
 * @param userAccountKey - User's Account public key
 * @param programId - deployed program ID for Points program
 * @returns [User Points Account public key, bump seed]
 */
export const findUserPointsAccount = async (
  pointsCategoryAccountKey: PublicKey,
  userAccountKey: PublicKey,
  programId: PublicKey
): Promise<[PublicKey, number]> => {
  return await PublicKey.findProgramAddress(
    [USER_POINTS_ACCOUNT_SEED, pointsCategoryAccountKey.toBuffer(), userAccountKey.toBuffer()],
    programId
  );
};

/**
 * Returns the public key and bump seed for the Points Modifier Account
 *
 * @param pointsCategoryAccountKey - Points Category Account public key
 * @param modifierKey - Modifier public key
 * @param programId - deployed program ID for XP program
 * @returns [Points Modifier Account public key, bump seed]
 */
export const findPointsModifierAccount = async (
  pointsCategoryAccountKey: PublicKey,
  modifierKey: PublicKey,
  programId: PublicKey
): Promise<[PublicKey, number]> => {
  return await PublicKey.findProgramAddress(
    [POINT_MODIFIER_SEED, pointsCategoryAccountKey.toBuffer(), modifierKey.toBuffer()],
    programId
  );
};

/**
 * Returns the base IDL for the Points program following as generated by Anchor with provided program ID appended to metadata.
 *
 * @param programId - Deployed program ID for the Points program
 * @returns - The base IDL object
 */
export function getPointsIDL(programId: web3.PublicKey): unknown {
  const _tmp = IDL;
  _tmp['metadata'] = { address: programId.toBase58() };
  return _tmp;
}

/**
 * Get the Points Anchor program
 * @param connection - the Solana connection object
 * @param programId - Deployed program ID for the Points program
 * @returns the Points anchor program
 */
export const getPointsProgram = (
  connection: Connection,
  programId: web3.PublicKey
) => {
  const idl = getPointsIDL(programId);
  const provider = new Provider(connection, null, null);
  const program = new Program(<Points>idl, programId, provider);
  return program;
};

/** Base Params for instructions */
interface BaseParams {
  connection: Connection /** the Solana connection object */;
  programId: web3.PublicKey /** Deployed program ID for the Points program */;
}

/** Params for Init instruction */
export interface initializeDomainParams extends BaseParams {
  admin: PublicKey /** the admin public key */;
}

/**
 * Initialize a Domain Account
 * @param admin - the admin public key
 * @param connection - the Solana connection object
 * @param programId - Deployed program ID for the Points program
 */
export const initializeDomainIx = async ({
  admin,
  connection,
  programId
}: initializeDomainParams): Promise<{ accounts: web3.PublicKey[], instructions: Promise<web3.TransactionInstruction>[] }> => {
  const program = getPointsProgram(connection, programId);

  const instructions = [
    program.methods
      .initializeDomain('domain1')
      .accounts({admin})
      .instruction()
  ];

  return {    
    accounts: [],
    instructions,
  };
};

/** Params for Register Point Category Account instruction */
export interface RegisterPointCategoryAccountParams extends BaseParams {
  admin: PublicKey /** the admin public key */;
  label: string /** The XP account label */;
  pointLimit: BN /** The XP limit */;
  tokenRequired: boolean /** Whether a token is required */;
  tokenQty: BN /** The token quantity to burn*/;
  tokenMintKey?: PublicKey /** The required token mint */;
  isSpendable: boolean /** Deployed program ID for the Points program */
}

/**
 * Registers a Point Category Account
 * @param admin - the admin public key 
 * @param label - The XP account label 
 * @param pointLimit - The XP limit 
 * @param tokenRequired - Whether a token is required 
 * @param tokenQty - The token quantity to burn
 * @param tokenMintKey - The required token mint 
 * @param isSpendable - Wheter the type of point is spendable or not
 * @param connection - the Solana connection objec
 * @param programId - Deployed program ID for the Points program
 */
export const registerPointCategoryAccountIx = async ({
  admin,
  label,
  pointLimit,
  tokenRequired,
  tokenQty,
  tokenMintKey,
  isSpendable,
  connection,
  programId,
}: RegisterPointCategoryAccountParams): Promise<{ accounts: web3.PublicKey[], instructions: Promise<web3.TransactionInstruction>[] }> => {
  const program = getPointsProgram(connection, programId);
  let remainingAccounts = []

  if (tokenRequired && !tokenMintKey) {
    throw new Error('The token mint is required');
  }else if(tokenRequired && tokenMintKey){
    remainingAccounts = [{ pubkey: tokenMintKey, isWritable: false, isSigner: false }]
  }
  
  const instructions = [
    program.methods
      .registerPointCategoryAccount(
        label,
        tokenRequired,
        tokenQty,
        pointLimit,
        isSpendable
      ).accounts({ admin })
      .remainingAccounts(remainingAccounts)
      .instruction()
  ]

  return {
    accounts: [],
    instructions,
  };
};

/** Params for Deregister Point Category Account instruction */
export interface DeregisterPointCategoryAccountParams extends BaseParams {
  admin: PublicKey /** the admin public key */;
}

/**
 * De-registers a Point Category Account
 * @param admin - the admin public key 
 * @param connection - the Solana connection objec
 * @param programId - Deployed program ID for the Points program
 */
export const deregisterPointCategoryAccountIx = async ({
  admin,
  connection,
  programId,
}: DeregisterPointCategoryAccountParams): Promise<{ accounts: web3.PublicKey[], instructions: Promise<web3.TransactionInstruction>[] }> => {
  const program = getPointsProgram(connection, programId);

  const instructions = [
    program.methods
      .deregisterPointCategoryAccount()
      .accounts({ admin })
      .instruction()
  ];

  return {
    accounts: [],
    instructions,
  };
};

/** Params for Update Point Category Account instruction */
export interface UpdatePointCategoryAccountParams extends BaseParams {
  admin: PublicKey /** the admin public key */;
  pointLimit?: BN /** The XP limit */;
  tokenRequired?: boolean /** Whether a token is required */;
  tokenQty?: BN /** The required token quantity */;
  tokenMintKey?: PublicKey /** The required token mint */;
}

/**
 * Updates a Point Category Account
 * @param admin - the admin public key 
 * @param pointLimit - The XP limit 
 * @param tokenRequired - Whether a token is required 
 * @param tokenQty - The token quantity to burn
 * @param tokenMintKey - The required token mint 
 * @param connection - the Solana connection objec
 * @param programId - Deployed program ID for the Points program
 */
export const updatePointCategoryAccountIx = async ({
  admin,
  pointLimit,
  tokenRequired,
  tokenQty,
  tokenMintKey,
  connection,
  programId,
}: UpdatePointCategoryAccountParams): Promise<{ accounts: web3.PublicKey[], instructions: Promise<web3.TransactionInstruction>[] }> => {
  const program = getPointsProgram(connection, programId);
  let remainingAccounts = []

  if (tokenRequired && !tokenMintKey) {
    throw new Error('The token mint is required');
  }else if(tokenRequired && tokenMintKey){
    remainingAccounts = [{ pubkey: tokenMintKey, isWritable: false, isSigner: false }]
  }
  
  const instructions = [
    program.methods
      .updatePointCategoryAccount(
        pointLimit,
        tokenQty,
        tokenRequired,
      ).accounts({ admin })
      .remainingAccounts(remainingAccounts)
      .instruction()
  ]

  return {
    accounts: [],
    instructions,
  };
};

/** Params for Create User Point Account instruction */
export interface CreateUserPointAccountParams extends BaseParams {
  user: PublicKey /** the user public key */;
}

/**
 * Creates a user Point Account
 * @param user - the user public key
 * @param connection - the Solana connection objec
 * @param programId - Deployed program ID for the Points program
 */
export const createUserPointAccountIx = async ({
  user,
  connection,
  programId,
}: CreateUserPointAccountParams): Promise<{ accounts: web3.PublicKey[], instructions: Promise<web3.TransactionInstruction>[] }> => {
  const program = getPointsProgram(connection, programId);

  const instructions = [
    program.methods
      .createUserPointAccount()
      .accounts({ user })
      .instruction()
  ];

  return {
    accounts: [],
    instructions,
  };
};

/** Params for Create User Point Account instruction with license */
export interface CreateUserPointAccountWithLicenseParams
  extends CreateUserPointAccountParams {
  licenseTokenAccountKey: PublicKey /** the token account for the license to burn */;
  licenseMintAccountKey: PublicKey /** the mint of the license token account */;
}

/**
 * Creates a user Point Account when a license is required
 * @param user - the user public key
 * @param licenseTokenAccountKey - the token account for the license to burn 
 * @param licenseMintAccountKey - the mint of the license token account
 * @param connection - the Solana connection objec
 * @param programId - Deployed program ID for the Points program
 */
export const createUserPointAccountWithLicenseIx = async ({
  user,
  licenseTokenAccountKey,
  licenseMintAccountKey,
  connection,
  programId,
}: CreateUserPointAccountWithLicenseParams): Promise<{ accounts: web3.PublicKey[], instructions: Promise<web3.TransactionInstruction>[] }> => {
  const program = getPointsProgram(connection, programId);

  const instructions = [
    program.methods
      .createUserPointAccountWithLicense()
      .accounts({
        user,
        userTokenAccount: licenseTokenAccountKey,
        licenseMintAccount: licenseMintAccountKey,
        // tokenProgram: TOKEN_PROGRAM_ID,
      })
      .instruction()
  ];

  return {
    accounts: [],
    instructions,
  };
};

/** Params for Register Point Modifier instruction */
export interface RegisterPointModifierParams extends BaseParams {
  admin: PublicKey /** the admin public key */;
  canIncrement: boolean /** whether the modifier can increment XP */;
  canDecrement: boolean /** whether the modifier can decrement XP */;
  modifierKey: PublicKey /** the modifier public key */;
}

/**
 * Registers an Point modifier
 * @param admin - the admin public key
 * @param canIncrement - whether the modifier can increment XP
 * @param canDecrement - whether the modifier can decrement XP
 * @param modifierKey - the modifier public key
 * @param connection - the Solana connection objec
 * @param programId - Deployed program ID for the Points program
 */
export const registerPointModifierIx = async ({
  admin,
  canIncrement,
  canDecrement,
  modifierKey,
  connection,
  programId,
}: RegisterPointModifierParams): Promise<{ accounts: web3.PublicKey[], instructions: Promise<web3.TransactionInstruction>[] }> => {
  const program = getPointsProgram(connection, programId);

  const instructions = [
    program.methods
      .registerPointModifier(canIncrement, canDecrement)
      .accounts({
        admin,
        modifier: modifierKey,
      })
      .instruction()
  ];

  return {
    accounts: [],
    instructions,
  };
};

/** Params for Deregister Point Modifier instruction */
export interface DeregisterPointModifierParams extends BaseParams {
  admin: PublicKey /** the admin public key */;
  modifierKey: PublicKey /** the modifier public key */;
}

/**
 * De-registers a Point Modifier
 * @param admin - the admin public key
 * @param modifierKey - the modifier public key
 * @param connection - the Solana connection objec
 * @param programId - Deployed program ID for the Points program
 */
export const deregisterPointModifierIx = async ({
  admin,
  modifierKey,
  connection,
  programId,
}: DeregisterPointModifierParams): Promise<{ accounts: web3.PublicKey[], instructions: Promise<web3.TransactionInstruction>[] }> => {
  const program = getPointsProgram(connection, programId);

  const instructions = [
    program.methods
      .deregisterPointModifier()
      .accounts({
        admin,
        modifier: modifierKey,
      })
      .instruction()
  ];

  return {
    accounts: [],
    instructions,
  };
};

/** Params for XP Modify instruction */
export interface ModifyPointsParams extends BaseParams {
  user: PublicKey /** the admin public key */;
  newXpValue: BN /** the new XP value */;
  modifierKey: PublicKey /** the modifier public key */;
}

/**
 * Modifies a user XP account
 * @param param - the input parameters
 */
export const modifyPointsIx = async ({
  user,
  newXpValue,
  modifierKey,
  connection,
  programId,
}: ModifyPointsParams) => {
  const program = getPointsProgram(connection, programId);

  const instructions = [
    program.methods
      .modifyPoints(newXpValue)
      .accounts({
        userPointsAccount: user,
        modifier: modifierKey,
      })
      .instruction()
  ];

  return {
    accounts: [],
    instructions,
  };
};

/**
 * Gets a Domain account
 * @param param - the input parameters
 */
export const getDomainAccount = async ({
  connection,
  programId,
}: BaseParams) => {
  const program = getPointsProgram(connection, programId);
  const [domainAccountKey] = await findDomainAccount(program.programId);
  const domainAccount = await program.account.domainAccount.fetch(domainAccountKey);

  return {
    domainAccount: domainAccount as DomainAccount,
    domainAccountKey: domainAccountKey,
  };
};

/** Params for Points Account getter */
export interface GetXpAccountParams extends BaseParams {
  pointCategoryAccountKey: PublicKey /** the Points Account public key */;
}

/**
 * Gets an Points account
 * @param param - the input parameters
 */
export const getPointCategoryAccountKey = async ({
  pointCategoryAccountKey,
  connection,
  programId,
}: GetXpAccountParams) => {
  const program = getPointsProgram(connection, programId);
  const xpAccount = await program.account.pointCategoryAccount.fetch(pointCategoryAccountKey);

  return xpAccount as PointCategoryAccount;
};

/** Params for User Points Account Getter */
export interface GetUserXpAccountParams extends BaseParams {
  userXpAccountKey: PublicKey /** the Points Account public key */;
}

/**
 * Gets a user Points account
 * @param param - the input parameters
 */
export const getUserPointsAccount = async ({
  userXpAccountKey,
  connection,
  programId,
}: GetUserXpAccountParams) => {
  const program = getPointsProgram(connection, programId);
  const userXpAccount = await program.account.userPointsAccount.fetch(
    userXpAccountKey
  );

  return userXpAccount as UserPointsAccount;
};

/** Params for User Points Account Getter */
export interface GetUserXpAccountViaUserAndXpKeysParams extends BaseParams {
  user: PublicKey /** the Points Account public key */;
  xpAccountKey: PublicKey /** the Points Account public key */;
}

/**
 * Gets a user's Points account using the user and XP Account
 * @param param - the input parameters
 */
export const getUserPointsAccountViaUserAndXpKeys = async ({
  user,
  xpAccountKey,
  connection,
  programId,
}: GetUserXpAccountViaUserAndXpKeysParams) => {
  const program = getPointsProgram(connection, programId);
  const [userXpAccountKey] = await findUserPointsAccount(
    xpAccountKey,
    user,
    programId
  );
  const userXpAccount = await program.account.userPointsAccount.fetch(
    userXpAccountKey
  );

  return {
    userXpAccountKey,
    userXpAccount: userXpAccount as UserPointsAccount,
  };
};

/** Params for User Points Accounts Getter */
export interface GetUserXpAccountsParams extends BaseParams {
  user: PublicKey /** the Points Account public key */;
}

/**
 * Gets a user's Points accounts
 * @param param - the input parameters
 */
export const getUserPointsAccounts = async ({
  user,
  connection,
  programId,
}: GetUserXpAccountsParams) => {
  const program = getPointsProgram(connection, programId);
  const userXpAccounts: UserPointsAccountItem[] =
    await program.account.userPointsAccount.all([
      {
        memcmp: {
          offset: 8,
          bytes: user.toBase58(),
        },
      },
    ]);

  return userXpAccounts;
};

/** Params for Points Modifier account getter */
export interface GetXpModifierAccountParams extends BaseParams {
  xpModifierAccountKey: PublicKey /** the Points Account public key */;
}

/**
 * Gets an Points Modifier account
 * @param param - the input parameters
 */
export const getPointsModifierAccount = async ({
  xpModifierAccountKey,
  connection,
  programId,
}: GetXpModifierAccountParams) => {
  const program = getPointsProgram(connection, programId);
  const xpModifierAccount = await program.account.pointsModifier.fetch(
    xpModifierAccountKey
  );

  return xpModifierAccount as PointsModifier;
};

/** Params for User Points Account Getter */
export interface GetXpModifierAccountViaModifierAndXpKeysParams
  extends BaseParams {
  modifier: PublicKey /** the Xp Account public key */;
  xpAccountKey: PublicKey /** the Xp Account public key */;
}

/**
 * Gets a user's Points account using the user and Points Account
 * @param param - the input parameters
 */
export const getPointsModifierAccountViaModifierAndXpKeys = async ({
  modifier,
  xpAccountKey,
  connection,
  programId,
}: GetXpModifierAccountViaModifierAndXpKeysParams) => {
  const program = getPointsProgram(connection, programId);
  const [xpModifierAccountKey] = await findPointsModifierAccount(
    xpAccountKey,
    modifier,
    programId
  );
  const xpModifierAccount = await program.account.userPointsAccount.fetch(
    xpModifierAccountKey
  );

  return {
    xpModifierAccountKey,
    xpModifierAccount: xpModifierAccount as PointsModifier,
  };
};

/** Params for Points Account modifierss Getter */
export interface GetXpAccountModifiersParams extends BaseParams {
  xpAccountKey: PublicKey /** the Xp Account public key */;
}

/**
 * Gets an Points Account's registered Points modifier accounts
 * @param param - the input parameters
 */
export const getPointsAccountModifiers = async ({
  xpAccountKey,
  connection,
  programId,
}: GetXpAccountModifiersParams) => {
  const program = getPointsProgram(connection, programId);
  const modifiers = await program.account.pointsModifier.all([
    {
      memcmp: {
        offset: 40,
        bytes: xpAccountKey.toBase58(),
      },
    },
  ]);

  return modifiers as PointsModifierItem[];
};

/** Params for modifier Points Accounts Getter */
export interface GetModifierXpAccountsParams extends BaseParams {
  modifier: PublicKey /** the Points Account public key */;
}

/**
 * Gets Points modifiers that belong to a particular modifier
 * @param param - the input parameters
 */
export const getModifierPointsAccounts = async ({
  modifier,
  connection,
  programId,
}: GetModifierXpAccountsParams) => {
  const program = getPointsProgram(connection, programId);
  const modifiers = await program.account.pointsModifier.all([
    {
      memcmp: {
        offset: 8,
        bytes: modifier.toBase58(),
      },
    },
  ]);

  return modifiers as PointsModifierItem[];
};
